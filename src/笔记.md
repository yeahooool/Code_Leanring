# 常用数据操作函数和方法

## import os

1. `os.walk()`: yields a 3-tuple:(root, dirs, files) // dirpath, dirnames, filenames
2. `os.path.abspath(path)`: Return an absolute path.
3. `os.path.exists(workDir)`: Test whether a path exists. Returns False for broken symbolic links
4. `os.path.join(a, *p)`: Join two or more pathname components, inserting '/' as needed. If any component is an absolute path, all previous path components will be discarded. An empty last part will result in a path that ends with a separator.
5. `os.system(command)`: system 函数可以将字符串转化成命令在服务器上运行---如`command = "gen_dR.x | tee ./output/out"`
6. `os.makedirs()`,`os.mkdir()`：前者创建多层目录，如果前面的目录不存在会自动创建；后者创建路径中的最后一级目录，如果之前的目录不存在并且也需要创建的话就会报错。
7. `os.path.split()` and `split(',')`: split()：拆分字符串。通过指定分隔符对字符串进行切片，并返回分割后的字符串列表（list）; os.path.split()：按照路径将文件名和路径分割开。

## with open() as f:

```python
with open('./filename.txt', 'r') as f:
   content = f.read(f)  #文件的读操作

with open('data.txt', 'w') as f:
   f.write('hello world')  #文件的写操作
```

相关参数：

```dotnetcli
r:	 # 以只读方式打开文件。文件的指针将会放在文件的开头。这是**默认模式**。
rb:  # 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。
r+:  # 打开一个文件用于读写。文件指针将会放在文件的开头。
rb+: # 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。
w:	 # 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。
wb:	 # 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。
w+:	 # 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。
wb+: # 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。
a:	 # 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。
ab:	 # 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。
a+:	 # 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。
ab+: # 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。
```

file 对象的属性：

```dotnetcli
file.read([size])        #将文件数据作为字符串返回，可选参数size控制读取的字节数
file.readlines([size])   #返回文件中行内容的列表，size参数可选
file.write(str)          #将字符串写入文件
file.writelines(strings) #将字符串序列写入文件
file.close()             #关闭文件
file.closed	             #表示文件已经被关闭，否则为False

file.mode	             #Access文件打开时使用的访问模式
file.encoding	         #文件所使用的编码
file.name	             #文件名
file.newlines	         #未读取到行分隔符时为None，只有一种行分隔符时为一个字符串，当文件有多种类型的行结束符时，
                         #则为一个包含所有当前所遇到的行结束的列表
file.softspace	         #为0表示在输出一数据后，要加上一个空格符，1表示不加。这个属性一般程序员用不着，由程序内部使用
```

## import subprocess as sp

1. `sp.check_output()`: Run command with arguments and return its output.
   ```python
   tgt = os.path.join(movement_file, "MOVEMENT")
   res = sp.check_output(["grep", "Iteration", tgt ,"-c"])
   ```
   > grep ... -c 表示出现次数

## enumerate()

enumerate 对象产生的对包含一个计数（从开始，默认为零）和一个由 iterable 参数产生的值。

enumerate is useful for obtaining an indexed list:
(0, seq[0]), (1, seq[1]), (2, seq[2]), ...

```python
for idx, line in enumerate(lines):
    pass
```

## import numpy as np

1. `np.linalg.det()`: numpy.linalg --- NumPy 的线性代数函数; linalg.det 计算一个数组的行列式。

   ```python
    Examples
    --------
    The determinant of a 2-D array [[a, b], [c, d]] is ad - bc:

    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.det(a)
    -2.0 # may vary

    Computing determinants for a stack of matrices:

    >>> a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
    >>> a.shape
    (3, 2, 2)
    >>> np.linalg.det(a)
    array([-2., -3., -8.])
   ```

): 2. `np.save(file, arr, allow_pickle=True, fix_imports=True)`:

```python
"""
 Save an array to a binary file in NumPy ``.npy`` format.

 Parameters
 ----------
 file : file, str, or pathlib.Path
     File or filename to which the data is saved.  If file is a file-object,
     then the filename is unchanged.  If file is a string or Path, a ``.npy``
     extension will be appended to the filename if it does not already
     have one.
 arr : array_like
     Array data to be saved.
 allow_pickle : bool, optional
     Allow saving object arrays using Python pickles. Reasons for disallowing
     pickles include security (loading pickled data can execute arbitrary
     code) and portability (pickled objects may not be loadable on different
     Python installations, for example if the stored objects require libraries
     that are not available, and not all pickled data is compatible between
     Python 2 and Python 3).
     Default: True
 fix_imports : bool, optional
     Only useful in forcing objects in object arrays on Python 3 to be
     pickled in a Python 2 compatible way. If `fix_imports` is True, pickle
     will try to map the new Python 3 names to the old module names used in
     Python 2, so that the pickle data stream is readable with Python 2.

 See Also
 --------
 savez : Save several arrays into a ``.npz`` archive
 savetxt, load

 Notes
 -----
 For a description of the ``.npy`` format, see :py:mod:`numpy.lib.format`.

 Any data saved to the file is appended to the end of the file.
```

3. `np.tile(A, reps)`:

   ```python
   Construct an array by repeating A the number of times given by reps.
   Parameters
   ----------
   A : array_like
       The input array.
   reps : array_like
       The number of repetitions of `A` along each axis.

   Returns
   -------
   c : ndarray
       The tiled output array.

   See Also
   --------
   repeat : Repeat elements of an array.
   broadcast_to : Broadcast an array to a new shape

   Examples
   --------
   >>> a = np.array([0, 1, 2])
   >>> np.tile(a, 2)
   array([0, 1, 2, 0, 1, 2])
   >>> np.tile(a, (2, 2))
   array([[0, 1, 2, 0, 1, 2],
          [0, 1, 2, 0, 1, 2]])
   >>> np.tile(a, (2, 1, 2))
   array([[[0, 1, 2, 0, 1, 2]],
          [[0, 1, 2, 0, 1, 2]]])

   >>> b = np.array([[1, 2], [3, 4]])
   >>> np.tile(b, 2)
   array([[1, 2, 1, 2],
          [3, 4, 3, 4]])
   >>> np.tile(b, (2, 1))
   array([[1, 2],
          [3, 4],
          [1, 2],
          [3, 4]])

   >>> c = np.array([1,2,3,4])
   >>> np.tile(c,(4,1))
   array([[1, 2, 3, 4],
          [1, 2, 3, 4],
          [1, 2, 3, 4],
          [1, 2, 3, 4]])
   ```

4. `np.concatenate(arrays, axis=None, out=None, *, dtype=None, casting=None)`:

   ```python
   concatenate((a1, a2, ...), axis=0, out=None, dtype=None, casting="same_kind")

   Join a sequence of arrays along an existing axis.

   Parameters
   ----------
   a1, a2, ... : sequence of array_like
       The arrays must have the same shape, except in the dimension
       corresponding to `axis` (the first, by default).
   axis : int, optional
       The axis along which the arrays will be joined.  If axis is None,
       arrays are flattened before use.  Default is 0.
   out : ndarray, optional
       If provided, the destination to place the result. The shape must be
       correct, matching that of what concatenate would have returned if no
       out argument were specified.
   dtype : str or dtype
       If provided, the destination array will have this dtype. Cannot be
       provided together with `out`.

   casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
       Controls what kind of data casting may occur. Defaults to 'same_kind'.

   Returns
   -------
   res : ndarray
       The concatenated array.

   See Also
   --------
   ma.concatenate : Concatenate function that preserves input masks.
   array_split : Split an array into multiple sub-arrays of equal or
                 near-equal size.
   split : Split array into a list of multiple sub-arrays of equal size.
   hsplit : Split array into multiple sub-arrays horizontally (column wise).
   vsplit : Split array into multiple sub-arrays vertically (row wise).
   dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).
   stack : Stack a sequence of arrays along a new axis.
   block : Assemble arrays from blocks.
   hstack : Stack arrays in sequence horizontally (column wise).
   vstack : Stack arrays in sequence vertically (row wise).
   dstack : Stack arrays in sequence depth wise (along third dimension).
   column_stack : Stack 1-D arrays as columns into a 2-D array.

   Examples
   --------
   >>> a = np.array([[1, 2], [3, 4]])
   >>> b = np.array([[5, 6]])
   >>> np.concatenate((a, b), axis=0)
   array([[1, 2],
          [3, 4],
          [5, 6]])
   >>> np.concatenate((a, b.T), axis=1)
   array([[1, 2, 5],
          [3, 4, 6]])
   >>> np.concatenate((a, b), axis=None)
   array([1, 2, 3, 4, 5, 6])
   ```

5. `np.loadtxt()`: Load data from a text file.
6. `np.insert(arr, obj, values, axis=None)`:

    ```python
    Insert values along the given axis before the given indices.

    Parameters
    ----------
    arr : array_like
        Input array.
    obj : int, slice or sequence of ints
        Object that defines the index or indices before which `values` is
        inserted.

        .. versionadded:: 1.8.0

        Support for multiple insertions when `obj` is a single scalar or a
        sequence with one element (similar to calling insert multiple
        times).
    values : array_like
        Values to insert into `arr`. If the type of `values` is different
        from that of `arr`, `values` is converted to the type of `arr`.
        `values` should be shaped so that ``arr[...,obj,...] = values``
        is legal.
    axis : int, optional
        Axis along which to insert `values`.  If `axis` is None then `arr`
        is flattened first.

    Returns
    -------
    out : ndarray
        A copy of `arr` with `values` inserted.  Note that `insert`
        does not occur in-place: a new array is returned. If
        `axis` is None, `out` is a flattened array.

    See Also
    --------
    append : Append elements at the end of an array.
    concatenate : Join a sequence of arrays along an existing axis.
    delete : Delete elements from an array.

    Notes
    -----
    Note that for higher dimensional inserts ``obj=0`` behaves very different
    from ``obj=[0]`` just like ``arr[:,0,:] = values`` is different from
    ``arr[:,[0],:] = values``.

    Examples
    --------
    >>> a = np.array([[1, 1], [2, 2], [3, 3]])
    >>> a
    array([[1, 1],
           [2, 2],
           [3, 3]])
    >>> np.insert(a, 1, 5)
    array([1, 5, 1, ..., 2, 3, 3])
    >>> np.insert(a, 1, 5, axis=1)
    array([[1, 5, 1],
           [2, 5, 2],
           [3, 5, 3]])

    Difference between sequence and scalars:

    >>> np.insert(a, [1], [[1],[2],[3]], axis=1)
    array([[1, 1, 1],
           [2, 2, 2],
           [3, 3, 3]])
    >>> np.array_equal(np.insert(a, 1, [1, 2, 3], axis=1),
    ...                np.insert(a, [1], [[1],[2],[3]], axis=1))
    True

    >>> b = a.flatten()
    >>> b
    array([1, 1, 2, 2, 3, 3])
    >>> np.insert(b, [2, 2], [5, 6])
    array([1, 1, 5, ..., 2, 3, 3])

    >>> np.insert(b, slice(2, 4), [5, 6])
    array([1, 1, 5, ..., 2, 3, 3])

    >>> np.insert(b, [2, 2], [7.13, False]) # type casting
    array([1, 1, 7, ..., 2, 3, 3])

    >>> x = np.arange(8).reshape(2, 4)
    >>> idx = (1, 3)
    >>> np.insert(x, idx, 999, axis=1)
    array([[  0, 999,   1,   2, 999,   3],
           [  4, 999,   5,   6, 999,   7]])
    ```

## imort torch

1. `torch.zeros_like(Tensor, dtype)`: 返回一个为 0 的 Tensor
