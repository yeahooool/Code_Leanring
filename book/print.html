<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Blog</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="blog">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">简介</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Python | 常用数据操作函数和方法</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="nested/open.html"><strong aria-hidden="true">1.1.</strong> with open() as f</a></li><li class="chapter-item expanded "><a href="nested/subprocess.html"><strong aria-hidden="true">1.2.</strong> subprocess</a></li><li class="chapter-item expanded "><a href="nested/enumerate.html"><strong aria-hidden="true">1.3.</strong> enumerate()</a></li><li class="chapter-item expanded "><a href="nested/random.html"><strong aria-hidden="true">1.4.</strong> random</a></li><li class="chapter-item expanded "><a href="nested/numpy.html"><strong aria-hidden="true">1.5.</strong> numpy</a></li><li class="chapter-item expanded "><a href="nested/torch.html"><strong aria-hidden="true">1.6.</strong> pytorch</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Python | 命令行解析接口</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="nested/os.html"><strong aria-hidden="true">2.1.</strong> os</a></li><li class="chapter-item expanded "><a href="nested/pathlib.html"><strong aria-hidden="true">2.2.</strong> pathlib</a></li><li class="chapter-item expanded "><a href="nested/sys.html"><strong aria-hidden="true">2.3.</strong> sys</a></li><li class="chapter-item expanded "><a href="nested/argparse.html"><strong aria-hidden="true">2.4.</strong> argparse</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Python | 特殊作用</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="nested/__var__.html"><strong aria-hidden="true">3.1.</strong> __下划线</a></li><li class="chapter-item expanded "><a href="nested/Magic_Method.html"><strong aria-hidden="true">3.2.</strong> Magic Method</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Python | 并行(parallel)</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="nested/Horovod.html"><strong aria-hidden="true">4.1.</strong> Horovod</a></li></ol></li><li class="chapter-item expanded "><a href="nested/others.html"><strong aria-hidden="true">5.</strong> Python | 其他</a></li><li class="chapter-item expanded "><a href="nested/fortran.html"><strong aria-hidden="true">6.</strong> Fortran | 基本知识</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Blog</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="test"><a class="header" href="#test">test</a></h1>
<p>studying...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="with-open-as-f"><a class="header" href="#with-open-as-f">with open() as f:</a></h1>
<pre><code class="language-python">with open('./filename.txt', 'r') as f:
   content = f.read(f)  #文件的读操作

with open('data.txt', 'w') as f:
   f.write('hello world')  #文件的写操作
</code></pre>
<p>相关参数：</p>
<pre><code class="language-dotnetcli">r:	 # 以只读方式打开文件。文件的指针将会放在文件的开头。这是**默认模式**。
rb:  # 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。
r+:  # 打开一个文件用于读写。文件指针将会放在文件的开头。
rb+: # 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。
w:	 # 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。
wb:	 # 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。
w+:	 # 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。
wb+: # 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。
a:	 # 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。
ab:	 # 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。
a+:	 # 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。
ab+: # 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。
</code></pre>
<p>file 对象的属性：</p>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
<pre><code class="language-dotnetcli">=======
```python
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3a98cd2 (update)
file.read([size])        #将文件数据作为字符串返回，可选参数size控制读取的字节数
file.readlines([size])   #返回文件中行内容的列表，size参数可选
file.write(str)          #将字符串写入文件
file.writelines(strings) #将字符串序列写入文件
file.close()             #关闭文件
file.closed	             #表示文件已经被关闭，否则为False

file.mode	             #Access文件打开时使用的访问模式
file.encoding	         #文件所使用的编码
file.name	             #文件名
file.newlines	         #未读取到行分隔符时为None，只有一种行分隔符时为一个字符串，当文件有多种类型的行结束符时，
                         #则为一个包含所有当前所遇到的行结束的列表
file.softspace	         #为0表示在输出一数据后，要加上一个空格符，1表示不加。这个属性一般程序员用不着，由程序内部使用
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="import-subprocess-as-sp"><a class="header" href="#import-subprocess-as-sp">import subprocess as sp</a></h1>
<ol>
<li><code>sp.check_output()</code>: Run command with arguments and return its output.
<pre><code class="language-python">tgt = os.path.join(movement_file, &quot;MOVEMENT&quot;)
res = sp.check_output([&quot;grep&quot;, &quot;Iteration&quot;, tgt ,&quot;-c&quot;])
</code></pre>
<blockquote>
<p>grep ... -c 表示出现次数</p>
</blockquote>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumerate"><a class="header" href="#enumerate">enumerate()</a></h1>
<p>enumerate 对象产生的对包含一个计数（从开始，默认为零）和一个由 iterable 参数产生的值。</p>
<p>enumerate is useful for obtaining an indexed list:
(0, seq[0]), (1, seq[1]), (2, seq[2]), ...</p>
<pre><code class="language-python">for idx, line in enumerate(lines):
    pass
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="import-random"><a class="header" href="#import-random">import random</a></h1>
<ol>
<li><code>random.shuffle(list)</code>: 输出乱序列表。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="import-numpy-as-np"><a class="header" href="#import-numpy-as-np">import numpy as np</a></h1>
<ol>
<li>
<p><code>np.linalg.det()</code>: numpy.linalg --- NumPy 的线性代数函数; linalg.det 计算一个数组的行列式。</p>
<pre><code class="language-python"> Examples
 --------
 The determinant of a 2-D array [[a, b], [c, d]] is ad - bc:

 &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])
 &gt;&gt;&gt; np.linalg.det(a)
 -2.0 # may vary

 Computing determinants for a stack of matrices:

 &gt;&gt;&gt; a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
 &gt;&gt;&gt; a.shape
 (3, 2, 2)
 &gt;&gt;&gt; np.linalg.det(a)
 array([-2., -3., -8.])
</code></pre>
</li>
</ol>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
<ol start="2">
<li>
<p><code>np.save(file, arr, allow_pickle=True, fix_imports=True)</code>:
=======</p>
</li>
<li>
<p><code>np.linalg.lstsq(a, b, rcond=&quot;warn&quot;)</code>:NumPy中的线性代数函数之一，用于求解线性最小二乘问题的解。线性最小二乘问题是指，给定一个矩阵X和一个向量y，求解最小化残差平方和的向量b，使得y ≈ Xb。</p>
<ul>
<li>a: 形状为(m,n)的2维数组，表示矩阵X。</li>
<li>b: 形状为(m,)或(m, k)的1维或2维数组，表示向量y。</li>
<li>rcond（可选）：浮点数或None，表示奇异值的截断阈值。奇异值是矩阵的特征值中非零的最小值，用于判断矩阵的秩。默认值为-1，表示使用numpy.finfo(a.dtype).eps * max(m, n)作为阈值。</li>
</ul>
<p>函数返回一个元组(x, residuals, rank, s)，其中：</p>
<ul>
<li>x：形状为(n,)或(n, k)的1维或2维数组，表示线性最小二乘问题的解b。</li>
<li>residuals：形状为()或(1,)的0维或1维数组，表示残差平方和。如果b的长度大于1，则返回一个包含多个残差平方和的数组。</li>
<li>rank：整数，表示矩阵X的秩。</li>
<li>s：形状为(min(m,n),)的1维数组，表示奇异值。</li>
</ul>
<p>下面是一个示例，演示如何求解线性最小二乘问题：</p>
<pre><code class="language-python">import numpy as np

# 定义矩阵X和向量y
X = np.array([[1, 1], [1, 2], [1, 3], [1, 4]])
y = np.array([2, 3, 4, 5])

# 求解线性最小二乘问题的解
b, residuals, rank, s = np.linalg.lstsq(X, y, rcond=None)

# 输出结果
print(&quot;解b：&quot;, b)
print(&quot;残差平方和：&quot;, residuals)
print(&quot;矩阵X的秩：&quot;, rank)
print(&quot;奇异值：&quot;, s)

&gt;&gt;&gt;
解b： [1. 1.]
残差平方和： [4.18001683e-32]
矩阵X的秩： 2
奇异值： [5.77937881 0.77380911]
</code></pre>
</li>
<li>
<p><code>np.save(file, arr, allow_pickle=True, fix_imports=True)</code>:
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3a98cd2 (update)</p>
<pre><code class="language-python"> Save an array to a binary file in NumPy ``.npy`` format.

 Parameters
 ----------
 file : file, str, or pathlib.Path
     File or filename to which the data is saved.  If file is a file-object,
     then the filename is unchanged.  If file is a string or Path, a ``.npy``
     extension will be appended to the filename if it does not already
     have one.
 arr : array_like
     Array data to be saved.
 allow_pickle : bool, optional
     Allow saving object arrays using Python pickles. Reasons for disallowing
     pickles include security (loading pickled data can execute arbitrary
     code) and portability (pickled objects may not be loadable on different
     Python installations, for example if the stored objects require libraries
     that are not available, and not all pickled data is compatible between
     Python 2 and Python 3).
     Default: True
 fix_imports : bool, optional
     Only useful in forcing objects in object arrays on Python 3 to be
     pickled in a Python 2 compatible way. If `fix_imports` is True, pickle
     will try to map the new Python 3 names to the old module names used in
     Python 2, so that the pickle data stream is readable with Python 2.

 See Also
 --------
 savez : Save several arrays into a ``.npz`` archive
 savetxt, load

 Notes
 -----
 For a description of the ``.npy`` format, see :py:mod:`numpy.lib.format`.

 Any data saved to the file is appended to the end of the file.
</code></pre>
</li>
</ol>
<h1>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
3. <code>np.tile(A, reps)</code>:</h1>
<ol start="4">
<li>
<p><code>np.tile(A, reps)</code>:
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3a98cd2 (update)</p>
<pre><code class="language-python">Construct an array by repeating A the number of times given by reps.
Parameters
----------
A : array_like
    The input array.
reps : array_like
    The number of repetitions of `A` along each axis.

Returns
-------
c : ndarray
    The tiled output array.

See Also
--------
repeat : Repeat elements of an array.
broadcast_to : Broadcast an array to a new shape

Examples
--------
&gt;&gt;&gt; a = np.array([0, 1, 2])
&gt;&gt;&gt; np.tile(a, 2)
array([0, 1, 2, 0, 1, 2])
&gt;&gt;&gt; np.tile(a, (2, 2))
array([[0, 1, 2, 0, 1, 2],
       [0, 1, 2, 0, 1, 2]])
&gt;&gt;&gt; np.tile(a, (2, 1, 2))
array([[[0, 1, 2, 0, 1, 2]],
       [[0, 1, 2, 0, 1, 2]]])

&gt;&gt;&gt; b = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; np.tile(b, 2)
array([[1, 2, 1, 2],
       [3, 4, 3, 4]])
&gt;&gt;&gt; np.tile(b, (2, 1))
array([[1, 2],
       [3, 4],
       [1, 2],
       [3, 4]])

&gt;&gt;&gt; c = np.array([1,2,3,4])
&gt;&gt;&gt; np.tile(c,(4,1))
array([[1, 2, 3, 4],
       [1, 2, 3, 4],
       [1, 2, 3, 4],
       [1, 2, 3, 4]])
</code></pre>
</li>
</ol>
<h1>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
4. <code>np.concatenate(arrays, axis=None, out=None, *, dtype=None, casting=None)</code>:</h1>
<ol start="5">
<li>
<p><code>np.concatenate(arrays, axis=None, out=None, *, dtype=None, casting=None)</code>:
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3a98cd2 (update)</p>
<pre><code class="language-python">concatenate((a1, a2, ...), axis=0, out=None, dtype=None, casting=&quot;same_kind&quot;)

Join a sequence of arrays along an existing axis.

Parameters
----------
a1, a2, ... : sequence of array_like
    The arrays must have the same shape, except in the dimension
    corresponding to `axis` (the first, by default).
axis : int, optional
    The axis along which the arrays will be joined.  If axis is None,
    arrays are flattened before use.  Default is 0.
out : ndarray, optional
    If provided, the destination to place the result. The shape must be
    correct, matching that of what concatenate would have returned if no
    out argument were specified.
dtype : str or dtype
    If provided, the destination array will have this dtype. Cannot be
    provided together with `out`.

casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur. Defaults to 'same_kind'.

Returns
-------
res : ndarray
    The concatenated array.

See Also
--------
ma.concatenate : Concatenate function that preserves input masks.
array_split : Split an array into multiple sub-arrays of equal or
              near-equal size.
split : Split array into a list of multiple sub-arrays of equal size.
hsplit : Split array into multiple sub-arrays horizontally (column wise).
vsplit : Split array into multiple sub-arrays vertically (row wise).
dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).
stack : Stack a sequence of arrays along a new axis.
block : Assemble arrays from blocks.
hstack : Stack arrays in sequence horizontally (column wise).
vstack : Stack arrays in sequence vertically (row wise).
dstack : Stack arrays in sequence depth wise (along third dimension).
column_stack : Stack 1-D arrays as columns into a 2-D array.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; b = np.array([[5, 6]])
&gt;&gt;&gt; np.concatenate((a, b), axis=0)
array([[1, 2],
       [3, 4],
       [5, 6]])
&gt;&gt;&gt; np.concatenate((a, b.T), axis=1)
array([[1, 2, 5],
       [3, 4, 6]])
&gt;&gt;&gt; np.concatenate((a, b), axis=None)
array([1, 2, 3, 4, 5, 6])
</code></pre>
</li>
</ol>
<h1>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
5. <code>np.loadtxt()</code>: Load data from a text file.
6. <code>np.insert(arr, obj, values, axis=None)</code>:</h1>
<ol start="6">
<li>
<p><code>np.loadtxt()</code>: Load data from a text file.</p>
</li>
<li>
<p><code>np.insert(arr, obj, values, axis=None)</code>:
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3a98cd2 (update)</p>
<pre><code class="language-python">Insert values along the given axis before the given indices.

Parameters
----------
arr : array_like
    Input array.
obj : int, slice or sequence of ints
    Object that defines the index or indices before which `values` is
    inserted.

    .. versionadded:: 1.8.0

    Support for multiple insertions when `obj` is a single scalar or a
    sequence with one element (similar to calling insert multiple
    times).
values : array_like
    Values to insert into `arr`. If the type of `values` is different
    from that of `arr`, `values` is converted to the type of `arr`.
    `values` should be shaped so that ``arr[...,obj,...] = values``
    is legal.
axis : int, optional
    Axis along which to insert `values`.  If `axis` is None then `arr`
    is flattened first.

Returns
-------
out : ndarray
    A copy of `arr` with `values` inserted.  Note that `insert`
    does not occur in-place: a new array is returned. If
    `axis` is None, `out` is a flattened array.

See Also
--------
append : Append elements at the end of an array.
concatenate : Join a sequence of arrays along an existing axis.
delete : Delete elements from an array.

Notes
-----
Note that for higher dimensional inserts ``obj=0`` behaves very different
from ``obj=[0]`` just like ``arr[:,0,:] = values`` is different from
``arr[:,[0],:] = values``.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 1], [2, 2], [3, 3]])
&gt;&gt;&gt; a
array([[1, 1],
       [2, 2],
       [3, 3]])
&gt;&gt;&gt; np.insert(a, 1, 5)
array([1, 5, 1, ..., 2, 3, 3])
&gt;&gt;&gt; np.insert(a, 1, 5, axis=1)
array([[1, 5, 1],
       [2, 5, 2],
       [3, 5, 3]])

Difference between sequence and scalars:

&gt;&gt;&gt; np.insert(a, [1], [[1],[2],[3]], axis=1)
array([[1, 1, 1],
       [2, 2, 2],
       [3, 3, 3]])
&gt;&gt;&gt; np.array_equal(np.insert(a, 1, [1, 2, 3], axis=1),
...                np.insert(a, [1], [[1],[2],[3]], axis=1))
True

&gt;&gt;&gt; b = a.flatten()
&gt;&gt;&gt; b
array([1, 1, 2, 2, 3, 3])
&gt;&gt;&gt; np.insert(b, [2, 2], [5, 6])
array([1, 1, 5, ..., 2, 3, 3])

&gt;&gt;&gt; np.insert(b, slice(2, 4), [5, 6])
array([1, 1, 5, ..., 2, 3, 3])

&gt;&gt;&gt; np.insert(b, [2, 2], [7.13, False]) # type casting
array([1, 1, 7, ..., 2, 3, 3])

&gt;&gt;&gt; x = np.arange(8).reshape(2, 4)
&gt;&gt;&gt; idx = (1, 3)
&gt;&gt;&gt; np.insert(x, idx, 999, axis=1)
array([[  0, 999,   1,   2, 999,   3],
       [  4, 999,   5,   6, 999,   7]])
</code></pre>
</li>
</ol>
<h1>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
7. <code>np.unique(ar, return_index=False, return_inverse=False,    return_counts=False, axis=None, *, equal_nan=True)</code>:</h1>
<ol start="8">
<li>
<p><code>np.unique(ar, return_index=False, return_inverse=False,    return_counts=False, axis=None, *, equal_nan=True)</code>:
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3a98cd2 (update)</p>
<pre><code class="language-python"> Find the unique elements of an array.

 Returns the sorted unique elements of an array. There are three optional
 outputs in addition to the unique elements:

 * the indices of the input array that give the unique values
 * the indices of the unique array that reconstruct the input array
 * the number of times each unique value comes up in the input array

 Parameters
 ----------
 ar : array_like
     Input array. Unless `axis` is specified, this will be flattened if it
     is not already 1-D.
 return_index : bool, optional
     If True, also return the indices of `ar` (along the specified axis,
     if provided, or in the flattened array) that result in the unique array.
 return_inverse : bool, optional
     If True, also return the indices of the unique array (for the specified
     axis, if provided) that can be used to reconstruct `ar`.
 return_counts : bool, optional
     If True, also return the number of times each unique item appears
     in `ar`.
 axis : int or None, optional
     The axis to operate on. If None, `ar` will be flattened. If an integer,
     the subarrays indexed by the given axis will be flattened and treated
     as the elements of a 1-D array with the dimension of the given axis,
     see the notes for more details.  Object arrays or structured arrays
     that contain objects are not supported if the `axis` kwarg is used. The
     default is None.
 equal_nan : bool, optional
     If True, collapses multiple NaN values in the return array into one.


 Returns
 -------
 unique : ndarray
     The sorted unique values.
 unique_indices : ndarray, optional
     The indices of the first occurrences of the unique values in the
     original array. Only provided if `return_index` is True.
 unique_inverse : ndarray, optional
     The indices to reconstruct the original array from the
     unique array. Only provided if `return_inverse` is True.
 unique_counts : ndarray, optional
     The number of times each of the unique values comes up in the
     original array. Only provided if `return_counts` is True.

     .. versionadded:: 1.9.0

 See Also
 --------
 numpy.lib.arraysetops : Module with a number of other functions for
                         performing set operations on arrays.
 repeat : Repeat elements of an array.


 Examples
 --------
 &gt;&gt;&gt; np.unique([1, 1, 2, 2, 3, 3])
 array([1, 2, 3])
 &gt;&gt;&gt; a = np.array([[1, 1], [2, 3]])
 &gt;&gt;&gt; np.unique(a)
 array([1, 2, 3])

 Return the unique rows of a 2D array

 &gt;&gt;&gt; a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
 &gt;&gt;&gt; np.unique(a, axis=0)
 array([[1, 0, 0], [2, 3, 4]])

 Return the indices of the original array that give the unique values:

 &gt;&gt;&gt; a = np.array(['a', 'b', 'b', 'c', 'a'])
 &gt;&gt;&gt; u, indices = np.unique(a, return_index=True)
 &gt;&gt;&gt; u
 array(['a', 'b', 'c'], dtype='&lt;U1')
 &gt;&gt;&gt; indices
 array([0, 1, 3])
 &gt;&gt;&gt; a[indices]
 array(['a', 'b', 'c'], dtype='&lt;U1')

 Reconstruct the input array from the unique values and inverse:

 &gt;&gt;&gt; a = np.array([1, 2, 6, 4, 2, 3, 2])
 &gt;&gt;&gt; u, indices = np.unique(a, return_inverse=True)
 &gt;&gt;&gt; u
 array([1, 2, 3, 4, 6])
 &gt;&gt;&gt; indices
 array([0, 1, 4, 3, 1, 2, 1])
 &gt;&gt;&gt; u[indices]
 array([1, 2, 6, 4, 2, 3, 2])

 Reconstruct the input values from the unique values and counts:

 &gt;&gt;&gt; a = np.array([1, 2, 6, 4, 2, 3, 2])
 &gt;&gt;&gt; values, counts = np.unique(a, return_counts=True)
 &gt;&gt;&gt; values
 array([1, 2, 3, 4, 6])
 &gt;&gt;&gt; counts
 array([1, 3, 1, 1, 1])
 &gt;&gt;&gt; np.repeat(values, counts)
 array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
</code></pre>
</li>
</ol>
<h1>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
8. <code>np.math.ceil()</code>:在Python中，math模块包含许多数学运算，可以使用该模块轻松地执行这些运算。函数Math.ceil(x)返回大于数字x的最小整数值。如果number已经是整数，则返回相同的数字。</h1>
<ol start="9">
<li><code>np.math.ceil()</code>:在Python中，math模块包含许多数学运算，可以使用该模块轻松地执行这些运算。函数Math.ceil(x)返回大于数字x的最小整数值。如果number已经是整数，则返回相同的数字。</li>
<li><code>.tolist()</code>: NumPy中的一个函数，用于将NumPy数组转换为Python列表。
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3a98cd2 (update)</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="import-torch"><a class="header" href="#import-torch">import torch</a></h1>
<ol>
<li><code>torch.zeros_like(Tensor, dtype)</code>: 返回一个为 0 的 Tensor.</li>
</ol>
<h1>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
2. <code>torch.set_printoptions()</code>: 显示的元素精度</h1>
<ol start="2">
<li>
<p><code>torch.set_printoptions()</code>: 显示的元素精度。
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3a98cd2 (update)</p>
<details>
 <summary>详细解释</summary>
<pre><code class="language-python">def set_printoptions(
    precision=None,
    threshold=None,
    edgeitems=None,
    linewidth=None,
    profile=None,
    sci_mode=None,
):
    r&quot;&quot;&quot;Set options for printing. Items shamelessly taken from NumPy

    Args:
        precision: Number of digits of precision for floating point output
            (default = 4).
        threshold: Total number of array elements which trigger summarization
            rather than full `repr` (default = 1000).
        edgeitems: Number of array items in summary at beginning and end of
            each dimension (default = 3).
        linewidth: The number of characters per line for the purpose of
            inserting line breaks (default = 80). Thresholded matrices will
            ignore this parameter.
        profile: Sane defaults for pretty printing. Can override with any of
            the above options. (any one of `default`, `short`, `full`)
        sci_mode: Enable (True) or disable (False) scientific notation. If
            None (default) is specified, the value is defined by
            `torch._tensor_str._Formatter`. This value is automatically chosen
            by the framework.

    Example::

        &gt;&gt;&gt; # Limit the precision of elements
        &gt;&gt;&gt; torch.set_printoptions(precision=2)
        &gt;&gt;&gt; torch.tensor([1.12345])
        tensor([1.12])
        &gt;&gt;&gt; # Limit the number of elements shown
        &gt;&gt;&gt; torch.set_printoptions(threshold=5)
        &gt;&gt;&gt; torch.arange(10)
        tensor([0, 1, 2, ..., 7, 8, 9])
        &gt;&gt;&gt; # Restore defaults
        &gt;&gt;&gt; torch.set_printoptions(profile='default')
        &gt;&gt;&gt; torch.tensor([1.12345])
        tensor([1.1235])
        &gt;&gt;&gt; torch.arange(10)
        tensor([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

    &quot;&quot;&quot;
    if profile is not None:
        if profile == &quot;default&quot;:
            PRINT_OPTS.precision = 4
            PRINT_OPTS.threshold = 1000
            PRINT_OPTS.edgeitems = 3
            PRINT_OPTS.linewidth = 80
        elif profile == &quot;short&quot;:
            PRINT_OPTS.precision = 2
            PRINT_OPTS.threshold = 1000
            PRINT_OPTS.edgeitems = 2
            PRINT_OPTS.linewidth = 80
        elif profile == &quot;full&quot;:
            PRINT_OPTS.precision = 4
            PRINT_OPTS.threshold = inf
            PRINT_OPTS.edgeitems = 3
            PRINT_OPTS.linewidth = 80

    if precision is not None:
        PRINT_OPTS.precision = precision
    if threshold is not None:
        PRINT_OPTS.threshold = threshold
    if edgeitems is not None:
        PRINT_OPTS.edgeitems = edgeitems
    if linewidth is not None:
        PRINT_OPTS.linewidth = linewidth
    PRINT_OPTS.sci_mode = sci_mode
</code></pre>
</li>
</ol>
<h1>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
</details></h1>
<pre><code>&lt;/details&gt;
</code></pre>
<ol start="3">
<li>
<p><code>import torch.backends.cudnn as cudnn</code>: 为什么使用相同的网络结构，跑出来的效果完全不同，用的学习率，迭代次数，batch size 都是一样？固定随机数种子是非常重要的。但是如果你使用的是PyTorch等框架，还要看一下框架的种子是否固定了。还有，如果你用了cuda，别忘了cuda的随机数种子。这里还需要用到torch.backends.cudnn.deterministic.</p>
<p><code>torch.backends.cudnn.deterministic</code>是啥？顾名思义，将这个 flag 置为<code>True</code>的话，每次返回的卷积算法将是确定的，即默认算法。如果配合上设置 Torch 的随机种子为固定值的话，应该可以保证每次运行网络的时候相同输入的输出是固定的，代码大致这样:</p>
<pre><code class="language-python">def init_seeds(seed=0):
torch.manual_seed(seed) # sets the seed for generating random numbers.
torch.cuda.manual_seed(seed) # Sets the seed for generating random numbers for the current GPU. It’s safe to call this function if CUDA is not available; in that case, it is silently ignored.
torch.cuda.manual_seed_all(seed) # Sets the seed for generating random numbers on all GPUs. It’s safe to call this function if CUDA is not available; in that case, it is silently ignored.

if seed == 0:
    cudnn.deterministic = True
    cudnn.benchmark = False
</code></pre>
<blockquote>
<p><code>torch.backends.cudnn.benchmark = true</code>: 大部分情况下，设置这个 flag 可以让内置的 cuDNN 的 auto-tuner 自动寻找最适合当前配置的高效算法，来达到优化运行效率的问题。<br>
一般来讲，应该遵循以下准则：</p>
<ul>
<li>如果网络的输入数据维度或类型上变化不大，设置  <code>torch.backends.cudnn.benchmark = true</code>  可以增加运行效率；</li>
<li>如果网络的输入数据在每次 iteration 都变化的话，会导致 cnDNN 每次都会去寻找一遍最优配置，这样反而会降低运行效率。</li>
<li>为了避免计算结果的波动，设置<code>torch.backends.cudnn.deterministic = True</code>.</li>
</ul>
</blockquote>
</li>
<li></li>
</ol>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>3a98cd2 (update)</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="import-os"><a class="header" href="#import-os">import os</a></h1>
<ol>
<li><code>os.walk()</code>: yields a 3-tuple:(root, dirs, files) // dirpath, dirnames, filenames</li>
<li><code>os.path.abspath(path)</code>: Return an absolute path.</li>
<li><code>os.path.exists(workDir)</code>: Test whether a path exists. Returns False for broken symbolic links</li>
<li><code>os.path.join(a, *p)</code>: Join two or more pathname components, inserting '/' as needed. If any component is an absolute path, all previous path components will be discarded. An empty last part will result in a path that ends with a separator.</li>
<li><code>os.system(command)</code>: system 函数可以将字符串转化成命令在服务器上运行---如<code>command = &quot;gen_dR.x | tee ./output/out&quot;</code></li>
<li><code>os.makedirs()</code>,<code>os.mkdir()</code>：前者创建多层目录，如果前面的目录不存在会自动创建；后者创建路径中的最后一级目录，如果之前的目录不存在并且也需要创建的话就会报错。</li>
<li><code>os.path.split()</code> and <code>split(',')</code>: split()：拆分字符串。通过指定分隔符对字符串进行切片，并返回分割后的字符串列表（list）; os.path.split()：按照路径将文件名和路径分割开。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="import-pathlib"><a class="header" href="#import-pathlib">import pathlib</a></h1>
<ol>
<li>
<p><code>pathlib.Path(PurePath)</code>: PurePath subclass that can make system calls.</p>
<pre><code class="language-python">p = Path('D:/python/1.py')
&gt;&gt;&gt; D:\python\1.py

#可以这么使用,相当于os.path.join()
p1 = Path('D:/python')
p2 = p1/'123'
&gt;&gt;&gt; D:\python\123
</code></pre>
<blockquote>
<p><code>Path(__file__)</code>中<code>__file__</code>的作用是在执行python文件时，把当前目录添加到sys.path中，配合<a href="nested/sys.html">sys.path</a>使用:
<code>codepath = str(pathlib.Path(__file__).parent.resolve())</code>
<code> sys.path.append(codepath)</code></p>
</blockquote>
</li>
<li>
<p><code>Path.cwd()</code>: 获取当前路径</p>
</li>
<li>
<p><code>Path.parent()</code>: 以字符串的形式返回作为参数传递的路径的父目录。</p>
<pre><code class="language-python">from pathlib import Path

path1 = Path(r&quot;C:\folder\subfolder\myfile.txt&quot;)
path2 = Path(r&quot;C:\Myfile.txt&quot;)
print(path1.parent)
print(path2.parent)

&gt;&gt;&gt; 
C:\folder\subfolder
C:\
</code></pre>
</li>
<li>
<p><code>Path.resolve()</code>: 将路径或路径片段的序列解析为绝对路径</p>
<ul>
<li>对于给定的路径片段，是<strong>从右向左</strong>拼接处理，直至构造出绝对路径;</li>
<li>如果在处理完所有给定的 path 片段之后还未生成绝对路径，则需要加上当前工作目录。</li>
</ul>
<pre><code class="language-python">var path = require(&quot;path&quot;)     //引入node的path模块

path.resolve('/foo/bar', './baz')   // returns '/foo/bar/baz'
path.resolve('/foo/bar', 'baz')   // returns '/foo/bar/baz'
path.resolve('/foo/bar', '/baz')   // returns '/baz'
path.resolve('/foo/bar', '../baz')   // returns '/foo/baz'
path.resolve('home','/foo/bar', '../baz')   // returns '/foo/baz'
path.resolve('home','./foo/bar', '../baz')   // returns '当前工作目录/home/foo/baz'
path.resolve('home','foo/bar', '../baz')   // returns '当前工作目录/home/foo/baz'
</code></pre>
<p>相当于：</p>
<pre><code class="language-python">path.resolve('/foo/bar', '../baz')  

&gt;&gt;&gt; 
cd /foo/bar
cd ..
cd baz
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="import-sys"><a class="header" href="#import-sys">import sys</a></h1>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
<code>sys.path</code>指定模块搜索路径的列表。默认情况下，python 导入文件或者模块，会在<code>sys.path</code>里找模块的路径。如果在当前搜索路径列表<code>sys.path</code>中找不到该模块的话，就会报错。</p>
<hr />
<p>最常用的用法就是向<code>sys.path</code>中添加搜索路径</p>
<pre><code class="language-python">import sys
sys.path.append(path)  # path 代表的是一个路径
</code></pre>
<hr />
<p>使用示例:</p>
<ul>
<li>查看当前搜索路径</li>
</ul>
<pre><code class="language-python">In [2]: import sys

In [3]: sys.path
Out[3]: 
['/data/home/hfhuang/software/anaconda3/envs/p100/bin',
 '',
 '/opt/rh/devtoolset-8/root/usr/lib64/python2.7/site-packages',
 '/opt/rh/devtoolset-8/root/usr/lib/python2.7/site-packages',
 '/data/home/hfhuang/software/PWmatMLFF/src',
 '/data/home/hfhuang/software',
 '/data/home/hfhuang/software/anaconda3/envs/p100/lib/python38.zip',
 '/data/home/hfhuang/software/anaconda3/envs/p100/lib/python3.8',
 '/data/home/hfhuang/software/anaconda3/envs/p100/lib/python3.8/lib-dynload',
 '/data/home/hfhuang/.local/lib/python3.8/site-packages',
 '/data/home/hfhuang/software/anaconda3/envs/p100/lib/python3.8/site-packages',
 '/data/home/hfhuang/software/anaconda3/envs/p100/lib/python3.8/site-packages/op-0.0.0-py3.8-linux-x86_64.egg']
</code></pre>
<ul>
<li>
<p>意思是导入python模块时,需要从这些路径中寻找</p>
</li>
<li>
<p>添加新的搜索路径</p>
<ul>
<li>假设我要导入一个模块<code>md100</code>,路径为<code>/data/home/hfhuang/software/PWmatMLFF/src/pre_data/</code>,直接<code>import md100</code>,显示报错:</li>
</ul>
</li>
</ul>
<pre><code class="language-python">In [4]: import md100
---------------------------------------------------------------------------
ModuleNotFoundError                       Traceback (most recent call last)
Cell In[4], line 1
----&gt; 1 import md100

ModuleNotFoundError: No module named 'md100'
</code></pre>
<ul>
<li>添加路径后重新import:</li>
</ul>
<pre><code class="language-python">In [5]: sys.path.append('/data/home/hfhuang/software/PWmatMLFF/src/pre_data/')

In [6]: import md100

In [7]: sys.path
Out[7]: 
['/data/home/hfhuang/software/anaconda3/envs/p100/bin',
 '',
 '/opt/rh/devtoolset-8/root/usr/lib64/python2.7/site-packages',
 '/opt/rh/devtoolset-8/root/usr/lib/python2.7/site-packages',
 '/data/home/hfhuang/software/PWmatMLFF/src',
 '/data/home/hfhuang/software',
 '/data/home/hfhuang/software/anaconda3/envs/p100/lib/python38.zip',
 '/data/home/hfhuang/software/anaconda3/envs/p100/lib/python3.8',
 '/data/home/hfhuang/software/anaconda3/envs/p100/lib/python3.8/lib-dynload',
 '/data/home/hfhuang/.local/lib/python3.8/site-packages',
 '/data/home/hfhuang/software/anaconda3/envs/p100/lib/python3.8/site-packages',
 '/data/home/hfhuang/software/anaconda3/envs/p100/lib/python3.8/site-packages/op-0.0.0-py3.8-linux-x86_64.egg',
 '/data/home/hfhuang/software/PWmatMLFF/src/pre_data/']
</code></pre>
<p>=======</p>
<ol>
<li>
<p><code>sys.path</code>: 指定模块搜索路径的列表。默认情况下，python 导入文件或者模块，会在<code>sys.path</code>里找模块的路径。如果在当前搜索路径列表<code>sys.path</code>中找不到该模块的话，就会报错。</p>
<p>最常用的用法就是向<code>sys.path</code>中添加搜索路径</p>
<pre><code class="language-python">import sys
sys.path.append(path)  # path 代表的是一个路径
</code></pre>
<details>
<summary>使用示例:</summary>
<ul>
<li>查看当前搜索路径</li>
</ul>
<pre><code class="language-python">In [2]: import sys

In [3]: sys.path
Out[3]:
['/data/home/hfhuang/software/anaconda3/envs/p100/bin',
'',
'/opt/rh/devtoolset-8/root/usr/lib64/python2.7/site-packages',
'/opt/rh/devtoolset-8/root/usr/lib/python2.7/site-packages',
'/data/home/hfhuang/software/PWmatMLFF/src',
'/data/home/hfhuang/software',
'/data/home/hfhuang/software/anaconda3/envs/p100/lib/python38.zip',
'/data/home/hfhuang/software/anaconda3/envs/p100/lib/python3.8',
'/data/home/hfhuang/software/anaconda3/envs/p100/lib/python3.8/lib-dynload',
'/data/home/hfhuang/.local/lib/python3.8/site-packages',
'/data/home/hfhuang/software/anaconda3/envs/p100/lib/python3.8/site-packages',
'/data/home/hfhuang/software/anaconda3/envs/p100/lib/python3.8/site-packages/op-0.0.0-py3.8-linux-x86_64.egg']

</code></pre>
<ul>
<li>
<p>意思是导入python模块时,需要从这些路径中寻找</p>
</li>
<li>
<p>添加新的搜索路径</p>
<ul>
<li>假设我要导入一个模块<code>md100</code>,路径为<code>/data/home/hfhuang/software/PWmatMLFF/src/pre_data/</code>,直接<code>import md100</code>,显示报错:</li>
</ul>
</li>
</ul>
<pre><code class="language-python">In [4]: import md100
---------------------------------------------------------------------------
ModuleNotFoundError                       Traceback (most recent call last)
Cell In[4], line 1
----&gt; 1 import md100

ModuleNotFoundError: No module named 'md100'
</code></pre>
<ul>
<li>添加路径后重新 import:</li>
</ul>
<pre><code class="language-python">In [5]: sys.path.append('/data/home/hfhuang/software/PWmatMLFF/src/pre_data/')

In [6]: import md100

In [7]: sys.path
Out[7]:
['/data/home/hfhuang/software/anaconda3/envs/p100/bin',
  '',
  '/opt/rh/devtoolset-8/root/usr/lib64/python2.7/site-packages',
  '/opt/rh/devtoolset-8/root/usr/lib/python2.7/site-packages',
  '/data/home/hfhuang/software/PWmatMLFF/src',
  '/data/home/hfhuang/software',
  '/data/home/hfhuang/software/anaconda3/envs/p100/lib/python38.zip',
  '/data/home/hfhuang/software/anaconda3/envs/p100/lib/python3.8',
  '/data/home/hfhuang/software/anaconda3/envs/p100/lib/python3.8/lib-dynload',
  '/data/home/hfhuang/.local/lib/python3.8/site-packages',
  '/data/home/hfhuang/software/anaconda3/envs/p100/lib/python3.8/site-packages',
  '/data/home/hfhuang/software/anaconda3/envs/p100/lib/python3.8/site-packages/op-0.0.0-py3.8-linux-x86_64.egg',
  '/data/home/hfhuang/software/PWmatMLFF/src/pre_data/']
</code></pre>
</details>
</li>
<li>
<p><code>sys.argv</code>: 一个从程序外部获取参数的桥梁。因为我们从外部取得的参数可以是多个，所以获得的是一个列表（list)，也就是说 sys.argv 其实可以看作是一个列表，所以才能用[]提取其中的元素。其第一个元素是程序本身，随后才依次是外部给予的参数。</p>
<details>
<summary>使用示例:</summary>
<ul>
<li>假设存在文件<em>test.py</em>, 执行代码时：</li>
</ul>
<pre><code class="language-python">import sys
a=sys.argv
b=len(sys.argv)
print(a)
print(b)

&gt;&gt;&gt; ['test.py',]
    1
</code></pre>
<ul>
<li>再次运行代码python test.py coding:</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; ['test.py', 'coding']
    2
</code></pre>
</details>
</li>
<li></li>
</ol>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>3a98cd2 (update)</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="import-argparse"><a class="header" href="#import-argparse">import argparse</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="下划线命名约定"><a class="header" href="#下划线命名约定">下划线命名约定</a></h1>
<p>在Python中，变量名中的下划线是一种命名约定，用于指示变量的含义或作用。在具体的命名约定中，下划线有以下几种用法：</p>
<ol>
<li>
<p><code>_var</code>: 以单下划线开头的变量名被认为是“内部使用”或“私有的”，即表示该变量不应该在模块外部直接访问。但这只是一种惯例，并没有强制性规定，因为Python并没有提供真正的私有变量机制。</p>
</li>
<li>
<p><code>__var</code>: 以双下划线开头但不以双下划线结尾的变量名是“名称修饰”，即会在变量名前加上一个下划线和类名，例如 _classname__var。这种命名约定主要用于避免类的属性名与其子类的属性名冲突。</p>
</li>
<li>
<p><code>__var__</code>: 以双下划线开头和结尾的变量名是Python中的“魔术方法”（Magic Method）或“特殊方法”（Special Method），用于实现类的特殊行为。例如，__init__方法用于初始化一个对象，在创建对象时自动调用。</p>
</li>
<li>
<p><code>var_</code>: 以单下划线结尾的变量名通常用于避免与Python关键字产生冲突。</p>
</li>
</ol>
<p>下面是几个例子来解释这些约定：</p>
<pre><code class="language-python">class MyClass:
    def __init__(self):
        self._var = 1       # 私有变量
        self.__var = 2      # 名称修饰
        self.__var__ = 3    # 魔术方法
        self.var_ = 4       # 避免关键字冲突

obj = MyClass()
print(obj._var)           # 正常访问私有变量      &gt;&gt;&gt; 1
print(obj._MyClass__var)  # 访问名称修饰变量      &gt;&gt;&gt; 2
print(obj.__var__)        # 魔术方法，输出3       &gt;&gt;&gt; 3
print(obj.var_)           # 避免关键字冲突        &gt;&gt;&gt; 4

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="魔术方法magic-method"><a class="header" href="#魔术方法magic-method">魔术方法（Magic Method)</a></h1>
<ol>
<li>
<p><code>__getitem__</code>: Python中的一个魔术方法，用于实现对象的索引访问。当我们使用<code>[]</code>符号对一个对象进行索引操作时，实际上是在调用这个对象的<code>__getitem__</code>方法。</p>
<p><code>__getitem__</code>方法接收一个参数<code>key</code>，表示索引值，然后根据索引值返回相应的值。如果<code>key</code>是整数，则表示索引访问；如果<code>key</code>是切片对象，则表示切片访问。如果<code>key</code>不是合法的索引值，则抛出<code>IndexError</code>异常。</p>
<p>下面是一个示例，演示如何定义<code>__getitem__</code>方法来实现对象的索引访问：</p>
<pre><code class="language-python">class MyList:
def __init__(self, data):
    self.data = data

def __getitem__(self, key):
    if isinstance(key, int):
        if key &lt; 0 or key &gt;= len(self.data):
            raise IndexError('list index out of range')
        return self.data[key]
    elif isinstance(key, slice):
        start, stop, step = key.start, key.stop, key.step
        start = start or 0
        stop = stop or len(self.data)
        step = step or 1
        return [self.data[i] for i in range(start, stop, step)]
    else:
        raise TypeError('indices must be integers or slices')
</code></pre>
<p>在上面的代码中，我们定义了一个<code>MyList</code>类，它包含一个列表数据<code>data</code>。然后，我们在类中定义了<code>__getitem_</code>_方法，它接收一个参数<code>key</code>，表示索引值。如果<code>key</code>是整数，我们检查索引值是否合法，然后返回相应的元素。如果<code>key</code>是切片对象，我们解析切片对象，然后返回切片所表示的元素列表。如果<code>key</code>既不是整数也不是切片对象，则抛出<code>TypeError</code>异常。</p>
<p>使用上述代码，我们可以像使用普通列表一样使用<code>MyList</code>对象进行索引访问和切片访问：</p>
<pre><code class="language-python">mylist = MyList([1, 2, 3, 4, 5])
print(mylist[0])       # 输出1
print(mylist[-1])      # 输出5
print(mylist[1:3])     # 输出[2, 3]
print(mylist[::2])     # 输出[1, 3, 5]
</code></pre>
</li>
<li>
<p><code>__len__</code>: Python中的一个魔术方法，用于实现对象的长度计算。当我们使用<code>len()</code>函数对一个对象进行长度计算时，实际上是在调用这个对象的<code>__len__</code>方法。</p>
<p><code>__len__</code>方法不接收任何参数，它应该返回一个整数，表示对象的长度。如果对象没有长度，则应该抛出<code>TypeError</code>异常。</p>
<p>下面是一个示例，演示如何定义<code>__len__</code>方法来实现对象的长度计算：</p>
<pre><code class="language-python">class MyList:
    def __init__(self, data):
        self.data = data

    def __len__(self):
        return len(self.data)
</code></pre>
<p>在上面的代码中，我们定义了一个<code>MyList</code>类，它包含一个列表数据<code>data</code>。然后，我们在类中定义了<code>__len__</code>方法，它返回列表数据的长度。</p>
<p>使用上述代码，我们可以像使用普通列表一样使用<code>MyList</code>对象进行长度计算：</p>
<pre><code class="language-python">mylist = MyList([1, 2, 3, 4, 5])
print(len(mylist))     # 输出5
</code></pre>
<p>注意，Python中许多内置类型都实现了<code>__len__</code>方法，如列表、元组、字符串等。因此，当我们使用<code>len()</code>函数计算这些对象的长度时，也是调用它们的<code>__len__</code>方法。</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="import-horovodtorch-as-hvd"><a class="header" href="#import-horovodtorch-as-hvd">import horovod.torch as hvd</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python--其他"><a class="header" href="#python--其他">Python | 其他</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fortran-base"><a class="header" href="#fortran-base">Fortran base</a></h1>
<h1 id="变量"><a class="header" href="#变量">变量</a></h1>
<p>5 种内置数据类型</p>
<ul>
<li>
<p>integer —— 表示整数的数据，正数或负数</p>
</li>
<li>
<p>real —— 用于浮点数据（不是整数）</p>
</li>
<li>
<p>complex —— 由实部和虚部组成的对</p>
</li>
<li>
<p>character —— 用于文本数据</p>
</li>
<li>
<p>logical —— 用于表示布尔值（真或假）值的数据</p>
</li>
</ul>
<h1 id="声明变量"><a class="header" href="#声明变量">声明变量</a></h1>
<p>Fortran 代码不区分大小写</p>
<pre><code class="language-fortran">program variables
  implicit none

  integer :: amount
  real :: pi
  complex :: frequency
  character :: initial
  logical :: isOkay

end program variables
</code></pre>
<p>一旦我们声明了一个变量，我们就可以使用赋值运算符 <code>=</code> 对其进行赋值和重新赋值。</p>
<pre><code class="language-fortran">amount = 10
pi = 3.1415927
frequency = (1.0, -0.5)
initial = 'A'
isOkay = .false.
</code></pre>
<p>字符由单引号 (') 或双引号 (&quot;) 包围。</p>
<p>逻辑或布尔值可以是 <code>.true.</code> 或 <code>.false.</code>。</p>
<p>注意 “content=” 声明时的赋值：<code>integer :: amount = 1</code>。 这不是正常的初始化； 它暗示了 <code>save</code> 属性，这意味着变量在过程调用之间保留其值。好的做法是将变量分别初始化为它们的声明。</p>
<blockquote>
<p>当使用&quot;::&quot;运算符来声明一个变量时，Fortran 编译器会在编译时为这个变量分配内存，并将其初始化为 0。如果在声明变量时为它赋予一个初始值，如所示的 1，那么在分配内存后，变量将被初始化为这个值。</p>
<p>在这种情况下，声明&quot;fortran integer :: amount = 1&quot;意味着你正在定义一个整数类型的变量&quot;amount&quot;，并将其初始化为 1。这个变量可以在后续的代码中使用，其值可以改变。如果你在声明时不给变量赋值，那么它的值将被初始化为 0。</p>
</blockquote>
<h2 id="一些例子"><a class="header" href="#一些例子">一些例子</a></h2>
<ol>
<li><code>real*8 AL(3,3),Etotp</code>: 这是两个变量的声明，一个是<code>AL</code>，另一个是<code>Etotp</code>。 <code>real*8</code>指定了变量的数据类型为 8 字节的浮点数，也称为双精度实数。<code>AL</code>是一个二维数组，其维度为 3x3，意味着它包含 9 个浮点数。<code>Etotp</code>是一个单独的浮点数变量，类型为<code>real*8</code>。</li>
</ol>
<p>示例代码：</p>
<pre><code class="language-fortran">AL(1,1) = 1.0d0
AL(1,2) = 2.0d0
AL(1,3) = 3.0d0
AL(2,1) = 4.0d0
AL(2,2) = 5.0d0
AL(2,3) = 6.0d0
AL(3,1) = 7.0d0
AL(3,2) = 8.0d0
AL(3,3) = 9.0d0

Etotp = 10.0d0
</code></pre>
<ol start="2">
<li><code>real*8,allocatable,dimension (:,:) :: xatom,fatom</code>:这是两个可分配的（allocatable）二维数组变量<code>xatom</code>和<code>fatom</code>的声明。 <code>real*8</code>指定了这些变量的数据类型为 8 字节的浮点数，也称为双精度实数。<code>dimension(:,:)</code>说明它们是二维数组，且维度在运行时指定。<code>allocatable</code>指定这些数组是可分配的，这意味着它们的大小可以在程序运行时动态分配，并且可以根据需要重新分配大小。</li>
</ol>
<p>示例代码：</p>
<pre><code class="language-fortran">allocate(xatom(3,3))
allocate(fatom(3,3))

xatom(1,:) = [1.0d0, 2.0d0, 3.0d0]
xatom(2,:) = [4.0d0, 5.0d0, 6.0d0]
xatom(3,:) = [7.0d0, 8.0d0, 9.0d0]

fatom = xatom**2
</code></pre>
<p>这将分配 3x3 大小的 xatom 和 fatom 数组，并将 xatom 数组的第一行分配为 1,2,3。然后，使用逐元素平方运算符将 xatom 数组的平方分配给 fatom 数组，从而将 fatom 数组设置为[1.0d0, 4.0d0, 9.0d0]的第一行，[16.0d0, 25.0d0, 36.0d0]的第二行和[49.0d0, 64.0d0, 81.0d0]的第三行。</p>
<ol start="3">
<li><code>character(len=50) char_tmp(20)</code>:这是一个有 20 个元素的字符数组，每个元素都是 50 个字符长。</li>
</ol>
<p>示例代码：</p>
<pre><code class="language-fortran">character(len=50) char_tmp(20)
char_tmp(1) = 'Hello, '
char_tmp(2) = 'how are you?'
print *, char_tmp(1) // char_tmp(2)
</code></pre>
<p>这将输出“Hello, how are you?”，其中 // 是 Fortran 中的字符串连接运算符。</p>
<ol start="4">
<li><code>CHARACTER(LEN=200), OPTIONAL :: title_line</code>:这是一个可选的字符变量声明，它的长度为 200。使用 <code>OPTIONAL</code> 关键字声明的变量意味着变量是可选的，即在调用程序中可以选择性地传递它的值。</li>
</ol>
<p>示例代码：</p>
<pre><code class="language-fortran">SUBROUTINE read_data_file(filename)
    CHARACTER(LEN=200), OPTIONAL :: title_line
    CHARACTER(LEN=200) :: filename

    OPEN(10, FILE=filename)

    IF (PRESENT(title_line)) THEN
        READ(10, '(A)') title_line
    END IF

    ! read the data from the file

    CLOSE(10)
END SUBROUTINE
</code></pre>
<p>这个子程序打开一个名为 filename 的文件，并读取它的标题行（如果存在）。如果 title_line 变量在调用程序中被传递，则使用 PRESENT()函数检查它是否存在。如果存在，读取文件中的第一行数据到 title_line 变量中。</p>
<ol start="5">
<li><code>CHARACTER(LEN=*) :: title </code>:这是一个长度不固定的字符变量声明，它的长度可以根据存储的字符串内容进行自动调整。</li>
</ol>
<p>示例代码：</p>
<pre><code class="language-fortran">CHARACTER(LEN=*) :: title

title = 'My simulation results'

WRITE(*, '(A)') title
</code></pre>
<p>这将创建一个长度为 15 的字符变量 title，并将“ My simulation results ”字符串存储在其中。最后，它使用 WRITE 语句将 title 变量的值输出到控制台。因为 CHARACTER(LEN=*) 声明的变量长度是可变的，所以可以存储不同长度的字符串。</p>
<h1 id="表达式"><a class="header" href="#表达式">表达式</a></h1>
<p>常用的算术运算符集可用，按优先顺序列出：</p>
<div class="table-wrapper"><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody>
<tr><td>**</td><td>指数</td></tr>
<tr><td>*</td><td>乘法</td></tr>
<tr><td>/</td><td>除法</td></tr>
<tr><td>+</td><td>加法</td></tr>
<tr><td>-</td><td>减法</td></tr>
</tbody></table>
</div>
<h1 id="组织代码结构"><a class="header" href="#组织代码结构">组织代码结构</a></h1>
<p>Fortran 有两种形式的过程：</p>
<ul>
<li>
<p><strong>子例程</strong>：由 <code>call</code> 语句调用</p>
</li>
<li>
<p><strong>函数</strong>：在返回值的表达式或赋值中调用</p>
</li>
</ul>
<p>子程序和函数都可以通过 argument association 访问父范围内的变量；除非指定了 <code>value</code> 属性，否则这类似于按引用调用。</p>
<h2 id="子程序"><a class="header" href="#子程序">子程序</a></h2>
<p>子程序输入参数，称为 dummy arguments，在子程序名称后面的括号中指定；虚拟参数类型和属性在子例程的主体中声明，就像局部变量一样。</p>
<p>使用示例：</p>
<pre><code class="language-fortran">! Print matrix A to screen
subroutine print_matrix(n,m,A)
  implicit none
  integer, intent(in) :: n
  integer, intent(in) :: m
  real, intent(in) :: A(n, m)

  integer :: i

  do i = 1, n
    print *, A(i, 1:m)
  end do

end subroutine print_matrix
</code></pre>
<p>注意声明虚拟参数时附加的 <code>intent</code> 属性；这个可选属性向编译器表示参数是“只读”（<code>intent(in)</code>）“只写”（<code>intent(out)</code>）还是“读写”（<code>intent(inout)</code>) 在过程中。在这个例子中，子程序不会修改它的参数，因此所有的参数都是 <code>intent(in)</code>。</p>
<p>始终为虚拟参数指定 <code>intent</code> 属性是一种很好的做法；这允许编译器检查意外错误并提供自文档。</p>
<p>我们可以使用 <code>call</code> 语句从程序中调用此子例程：</p>
<pre><code class="language-fortran">program call_sub
  implicit none

  real :: mat(10, 20)

  mat(:,:) = 0.0

  call print_matrix(10, 20, mat)

end program call_sub
</code></pre>
<h2 id="函数"><a class="header" href="#函数">函数</a></h2>
<h2 id="模块"><a class="header" href="#模块">模块</a></h2>
<h2 id="interface"><a class="header" href="#interface">Interface</a></h2>
<p><code>INTERFACE</code> 是用于定义子程序和函数接口的语句块。它用于在主程序中声明子程序或函数的名称、参数、返回值类型和其他属性。这可以让编译器在编译时检查调用程序与被调用程序之间的数据类型、参数数目和参数顺序是否匹配，从而减少错误和调试时间。</p>
<p>在调用子程序时，使用 <code>CALL</code> 语句可以让程序执行特定的子程序。但在调用子程序时，必须确保传递的参数与子程序声明中的参数匹配，否则可能会出现编译错误或运行时错误。使用 <code>INTERFACE</code> 可以在编译时检查这些参数匹配错误，提高代码的可靠性和稳定性。</p>
<pre><code class="language-fortran">INTERFACE
    SUBROUTINE scan_title (io_file, title, title_line, if_find)
        CHARACTER(LEN=200), OPTIONAL :: title_line
        LOGICAL, OPTIONAL :: if_find
        INTEGER :: io_file
        CHARACTER(LEN=*) :: title
    END SUBROUTINE scan_title
END INTERFACE
</code></pre>
<h1 id="文件输入输出"><a class="header" href="#文件输入输出">文件输入/输出</a></h1>
<p>在 Fortran 中，文件由单元标识符管理。与文件系统的交互主要通过 <code>open</code> 和 <code>inquire</code> 内置程序进行。通常，工作流程是打开一个文件到一个单元标识符，读取和/或写入它，然后再次关闭它。</p>
<pre><code class="language-fortran">integer :: io
open(newunit=io, file=&quot;log.txt&quot;)
! ...
close(io)
</code></pre>
<p>默认情况下，如果文件不存在，则将创建该文件并打开以供读取和写入。写入现有文件将从第一条记录（行）开始，因此默认情况下会覆盖该文件。</p>
<p>要创建对文件的只读访问权限，必须使用指定的 <code>status</code> 和 <code>action</code></p>
<pre><code class="language-fortran">integer :: io
open(newunit=io, file=&quot;log.txt&quot;, status=&quot;old&quot;, action=&quot;read&quot;)
read(io, *) a, b
close(io)
</code></pre>
<p>如果文件不存在，则会发生运行时错误。要在打开文件之前检查文件是否存在，可以使用 <code>inquire</code> 函数</p>
<pre><code class="language-fortran">logical :: exists
inquire(file=&quot;log.txt&quot;, exist=exists)
if (exists) then
  ! ...
end if
</code></pre>
<p>或者，<code>open</code> 过程可以返回可选的 iostat 和 iomsg：</p>
<pre><code class="language-fortran">integer :: io, stat
character(len=512) :: msg
open(newunit=io, file=&quot;log.txt&quot;, status=&quot;old&quot;, action=&quot;read&quot;, &amp;
  iostat=stat, iomsg=msg)
if (stat /= 0) then
  print *, trim(msg)
end if
</code></pre>
<p>请注意，iomsg 需要一个具有足够存储大小的固定长度字符变量来保存错误消息。</p>
<p>同样，通过使用 status 和 action 关键字写入文件。</p>
<p>要创建一个新文件，请使用</p>
<pre><code class="language-fortran">integer :: io
open(newunit=io, file=&quot;log.txt&quot;, status=&quot;new&quot;, action=&quot;write&quot;)
write(io, *) a, b
close(io)
</code></pre>
<p>或者，<code>status=&quot;replace&quot;</code> 可用于覆盖现有文件。强烈建议在决定要使用的<em>status</em> 之前先检查文件是否存在。要附加到输出文件，可以使用显式指定 position 关键字</p>
<pre><code class="language-fortran">integer :: io
open(newunit=io, file=&quot;log.txt&quot;, position=&quot;append&quot;, &amp;
  &amp; status=&quot;old&quot;, action=&quot;write&quot;)
write(io, *) size(v)
write(io, *) v(:)
close(io)
</code></pre>
<p>要重置文件中的位置，可以使用内置程序<code>rewind</code>和<code>backspace</code>。 <code>rewind</code> 将文件指针重置为文件的开头，以便读取文件的第一行，而 <code>backspace</code> 将文件指针向后移动一个记录，也就是向后移动一个记录的长度。</p>
<p>最后，要删除文件，必须打开文件，并且可以在关闭后删除</p>
<pre><code class="language-fortran">logical :: exists
integer :: io, stat
inquire(file=&quot;log.txt&quot;, exist=exists)
if (exists) then
  open(file=&quot;log.txt&quot;, newunit=io, iostat=stat)
  if (stat == 0) close(io, status=&quot;delete&quot;, iostat=stat)
end if
</code></pre>
<p>一个有用的 IO 功能是暂存文件，可以使用 <code>status=&quot;scratch&quot; </code>打开。它们在关闭单元标识符后自动删除。</p>
<h1 id="其他使用"><a class="header" href="#其他使用">其他使用</a></h1>
<ol>
<li>
<p>编译：<code>ifort -o file_exe file1.f90 file2.f90 ...</code></p>
</li>
<li>
<p><code>read(10,*) Rc_M,m_neigh</code>:_ 符号用于指示一个读取/写入列表项应使用的格式。在这个例子中，_ 符号表示使用默认格式，读取从文件 10 中得到的下一个数据值，并将其分配给变量 Rc_M 和 m_neigh。</p>
<p>默认格式是指定读取或写入操作中不需要显式格式指令的方式，这在某些情况下可以方便地读取或写入简单的数据类型。但是，在某些情况下，可能需要使用显式格式控制，以确保数据被正确读取或写入。如果省略了 * 符号，则编译器将假定您提供了一个格式字符串，这可能会导致读取或写入错误。</p>
</li>
<li>
<p><code>read(13,'(a200)') trainSetDir</code>:这行代码是一个读取输入的语句。具体来说，它使用 <code>read</code> 命令从文件号为 13 的文件中读取一个长度为 200 个字符的字符串，并将其存储在 <code>trainSetDir</code> 变量中。</p>
<p><code>'(a200)'</code> 是一个格式说明符，用于告诉 <code>read</code> 命令应该如何解释从文件中读取的内容。在这个例子中，<code>(a200)</code> 表示读取一个长度为 200 的字符串（<code>a</code> 是字符串类型的格式符）。这意味着 <code>read</code> 命令将从文件中读取一个长度为 200 的字符串，并将其存储在 <code>trainSetDir</code> 变量中。</p>
<p>注意，如果输入字符串的长度超过了 200 个字符，则会被截断。如果输入字符串的长度小于 200 个字符，则其余的字符将被填充为零。</p>
</li>
<li>
<p><code>MOVEMENTDir=trim(trainSetFileDir(sys))</code> 函数用于删除字符串两端的空格。</p>
</li>
<li>
<p><code>write(1314, &quot;(3(E17.10, 1x), i4)&quot;) dR_neigh(1, i, j, k), dR_neigh(2, i, j, k), dR_neigh(3, i, j, k), list_neigh(i,j,k)</code>:&quot;(3(E17.10, 1x), i4)&quot; 是一个格式字符串，用来指定输出的数据格式，包括了以下几个部分：
<code>3</code>：指示这个格式字符串将会输出三个值；
<code>E17.10</code>：指示每个浮点数的宽度为 17，其中包括小数点和 10 位小数，即总共 17 个字符；
<code>1x</code>：指示每个浮点数和整数之间都有一个空格分隔符，以便于阅读；
<code>i4</code>：指示输出一个整数，宽度为 4，即总共 4 个字符。</p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
